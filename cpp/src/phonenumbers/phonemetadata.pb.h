// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: phonemetadata.proto

#ifndef PROTOBUF_phonemetadata_2eproto__INCLUDED
#define PROTOBUF_phonemetadata_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace i18n {
namespace phonenumbers {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_phonemetadata_2eproto();
void protobuf_AssignDesc_phonemetadata_2eproto();
void protobuf_ShutdownFile_phonemetadata_2eproto();

class NumberFormat;
class PhoneNumberDesc;
class PhoneMetadata;
class PhoneMetadataCollection;

// ===================================================================

class NumberFormat : public ::google::protobuf::MessageLite {
 public:
  NumberFormat();
  virtual ~NumberFormat();

  NumberFormat(const NumberFormat& from);

  inline NumberFormat& operator=(const NumberFormat& from) {
    CopyFrom(from);
    return *this;
  }

  static const NumberFormat& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NumberFormat* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NumberFormat* other);

  // implements Message ----------------------------------------------

  NumberFormat* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NumberFormat& from);
  void MergeFrom(const NumberFormat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string pattern = 1;
  inline bool has_pattern() const;
  inline void clear_pattern();
  static const int kPatternFieldNumber = 1;
  inline const ::std::string& pattern() const;
  inline void set_pattern(const ::std::string& value);
  inline void set_pattern(const char* value);
  inline void set_pattern(const char* value, size_t size);
  inline ::std::string* mutable_pattern();
  inline ::std::string* release_pattern();
  inline void set_allocated_pattern(::std::string* pattern);

  // required string format = 2;
  inline bool has_format() const;
  inline void clear_format();
  static const int kFormatFieldNumber = 2;
  inline const ::std::string& format() const;
  inline void set_format(const ::std::string& value);
  inline void set_format(const char* value);
  inline void set_format(const char* value, size_t size);
  inline ::std::string* mutable_format();
  inline ::std::string* release_format();
  inline void set_allocated_format(::std::string* format);

  // repeated string leading_digits_pattern = 3;
  inline int leading_digits_pattern_size() const;
  inline void clear_leading_digits_pattern();
  static const int kLeadingDigitsPatternFieldNumber = 3;
  inline const ::std::string& leading_digits_pattern(int index) const;
  inline ::std::string* mutable_leading_digits_pattern(int index);
  inline void set_leading_digits_pattern(int index, const ::std::string& value);
  inline void set_leading_digits_pattern(int index, const char* value);
  inline void set_leading_digits_pattern(int index, const char* value, size_t size);
  inline ::std::string* add_leading_digits_pattern();
  inline void add_leading_digits_pattern(const ::std::string& value);
  inline void add_leading_digits_pattern(const char* value);
  inline void add_leading_digits_pattern(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& leading_digits_pattern() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_leading_digits_pattern();

  // optional string national_prefix_formatting_rule = 4;
  inline bool has_national_prefix_formatting_rule() const;
  inline void clear_national_prefix_formatting_rule();
  static const int kNationalPrefixFormattingRuleFieldNumber = 4;
  inline const ::std::string& national_prefix_formatting_rule() const;
  inline void set_national_prefix_formatting_rule(const ::std::string& value);
  inline void set_national_prefix_formatting_rule(const char* value);
  inline void set_national_prefix_formatting_rule(const char* value, size_t size);
  inline ::std::string* mutable_national_prefix_formatting_rule();
  inline ::std::string* release_national_prefix_formatting_rule();
  inline void set_allocated_national_prefix_formatting_rule(::std::string* national_prefix_formatting_rule);

  // optional bool national_prefix_optional_when_formatting = 6;
  inline bool has_national_prefix_optional_when_formatting() const;
  inline void clear_national_prefix_optional_when_formatting();
  static const int kNationalPrefixOptionalWhenFormattingFieldNumber = 6;
  inline bool national_prefix_optional_when_formatting() const;
  inline void set_national_prefix_optional_when_formatting(bool value);

  // optional string domestic_carrier_code_formatting_rule = 5;
  inline bool has_domestic_carrier_code_formatting_rule() const;
  inline void clear_domestic_carrier_code_formatting_rule();
  static const int kDomesticCarrierCodeFormattingRuleFieldNumber = 5;
  inline const ::std::string& domestic_carrier_code_formatting_rule() const;
  inline void set_domestic_carrier_code_formatting_rule(const ::std::string& value);
  inline void set_domestic_carrier_code_formatting_rule(const char* value);
  inline void set_domestic_carrier_code_formatting_rule(const char* value, size_t size);
  inline ::std::string* mutable_domestic_carrier_code_formatting_rule();
  inline ::std::string* release_domestic_carrier_code_formatting_rule();
  inline void set_allocated_domestic_carrier_code_formatting_rule(::std::string* domestic_carrier_code_formatting_rule);

  // @@protoc_insertion_point(class_scope:i18n.phonenumbers.NumberFormat)
 private:
  inline void set_has_pattern();
  inline void clear_has_pattern();
  inline void set_has_format();
  inline void clear_has_format();
  inline void set_has_national_prefix_formatting_rule();
  inline void clear_has_national_prefix_formatting_rule();
  inline void set_has_national_prefix_optional_when_formatting();
  inline void clear_has_national_prefix_optional_when_formatting();
  inline void set_has_domestic_carrier_code_formatting_rule();
  inline void clear_has_domestic_carrier_code_formatting_rule();

  ::std::string* pattern_;
  ::std::string* format_;
  ::google::protobuf::RepeatedPtrField< ::std::string> leading_digits_pattern_;
  ::std::string* national_prefix_formatting_rule_;
  ::std::string* domestic_carrier_code_formatting_rule_;
  bool national_prefix_optional_when_formatting_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_phonemetadata_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_phonemetadata_2eproto();
  #endif
  friend void protobuf_AssignDesc_phonemetadata_2eproto();
  friend void protobuf_ShutdownFile_phonemetadata_2eproto();

  void InitAsDefaultInstance();
  static NumberFormat* default_instance_;
};
// -------------------------------------------------------------------

class PhoneNumberDesc : public ::google::protobuf::MessageLite {
 public:
  PhoneNumberDesc();
  virtual ~PhoneNumberDesc();

  PhoneNumberDesc(const PhoneNumberDesc& from);

  inline PhoneNumberDesc& operator=(const PhoneNumberDesc& from) {
    CopyFrom(from);
    return *this;
  }

  static const PhoneNumberDesc& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PhoneNumberDesc* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PhoneNumberDesc* other);

  // implements Message ----------------------------------------------

  PhoneNumberDesc* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PhoneNumberDesc& from);
  void MergeFrom(const PhoneNumberDesc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string national_number_pattern = 2;
  inline bool has_national_number_pattern() const;
  inline void clear_national_number_pattern();
  static const int kNationalNumberPatternFieldNumber = 2;
  inline const ::std::string& national_number_pattern() const;
  inline void set_national_number_pattern(const ::std::string& value);
  inline void set_national_number_pattern(const char* value);
  inline void set_national_number_pattern(const char* value, size_t size);
  inline ::std::string* mutable_national_number_pattern();
  inline ::std::string* release_national_number_pattern();
  inline void set_allocated_national_number_pattern(::std::string* national_number_pattern);

  // optional string possible_number_pattern = 3;
  inline bool has_possible_number_pattern() const;
  inline void clear_possible_number_pattern();
  static const int kPossibleNumberPatternFieldNumber = 3;
  inline const ::std::string& possible_number_pattern() const;
  inline void set_possible_number_pattern(const ::std::string& value);
  inline void set_possible_number_pattern(const char* value);
  inline void set_possible_number_pattern(const char* value, size_t size);
  inline ::std::string* mutable_possible_number_pattern();
  inline ::std::string* release_possible_number_pattern();
  inline void set_allocated_possible_number_pattern(::std::string* possible_number_pattern);

  // optional string example_number = 6;
  inline bool has_example_number() const;
  inline void clear_example_number();
  static const int kExampleNumberFieldNumber = 6;
  inline const ::std::string& example_number() const;
  inline void set_example_number(const ::std::string& value);
  inline void set_example_number(const char* value);
  inline void set_example_number(const char* value, size_t size);
  inline ::std::string* mutable_example_number();
  inline ::std::string* release_example_number();
  inline void set_allocated_example_number(::std::string* example_number);

  // @@protoc_insertion_point(class_scope:i18n.phonenumbers.PhoneNumberDesc)
 private:
  inline void set_has_national_number_pattern();
  inline void clear_has_national_number_pattern();
  inline void set_has_possible_number_pattern();
  inline void clear_has_possible_number_pattern();
  inline void set_has_example_number();
  inline void clear_has_example_number();

  ::std::string* national_number_pattern_;
  ::std::string* possible_number_pattern_;
  ::std::string* example_number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_phonemetadata_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_phonemetadata_2eproto();
  #endif
  friend void protobuf_AssignDesc_phonemetadata_2eproto();
  friend void protobuf_ShutdownFile_phonemetadata_2eproto();

  void InitAsDefaultInstance();
  static PhoneNumberDesc* default_instance_;
};
// -------------------------------------------------------------------

class PhoneMetadata : public ::google::protobuf::MessageLite {
 public:
  PhoneMetadata();
  virtual ~PhoneMetadata();

  PhoneMetadata(const PhoneMetadata& from);

  inline PhoneMetadata& operator=(const PhoneMetadata& from) {
    CopyFrom(from);
    return *this;
  }

  static const PhoneMetadata& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PhoneMetadata* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PhoneMetadata* other);

  // implements Message ----------------------------------------------

  PhoneMetadata* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PhoneMetadata& from);
  void MergeFrom(const PhoneMetadata& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .i18n.phonenumbers.PhoneNumberDesc general_desc = 1;
  inline bool has_general_desc() const;
  inline void clear_general_desc();
  static const int kGeneralDescFieldNumber = 1;
  inline const ::i18n::phonenumbers::PhoneNumberDesc& general_desc() const;
  inline ::i18n::phonenumbers::PhoneNumberDesc* mutable_general_desc();
  inline ::i18n::phonenumbers::PhoneNumberDesc* release_general_desc();
  inline void set_allocated_general_desc(::i18n::phonenumbers::PhoneNumberDesc* general_desc);

  // optional .i18n.phonenumbers.PhoneNumberDesc fixed_line = 2;
  inline bool has_fixed_line() const;
  inline void clear_fixed_line();
  static const int kFixedLineFieldNumber = 2;
  inline const ::i18n::phonenumbers::PhoneNumberDesc& fixed_line() const;
  inline ::i18n::phonenumbers::PhoneNumberDesc* mutable_fixed_line();
  inline ::i18n::phonenumbers::PhoneNumberDesc* release_fixed_line();
  inline void set_allocated_fixed_line(::i18n::phonenumbers::PhoneNumberDesc* fixed_line);

  // optional .i18n.phonenumbers.PhoneNumberDesc mobile = 3;
  inline bool has_mobile() const;
  inline void clear_mobile();
  static const int kMobileFieldNumber = 3;
  inline const ::i18n::phonenumbers::PhoneNumberDesc& mobile() const;
  inline ::i18n::phonenumbers::PhoneNumberDesc* mutable_mobile();
  inline ::i18n::phonenumbers::PhoneNumberDesc* release_mobile();
  inline void set_allocated_mobile(::i18n::phonenumbers::PhoneNumberDesc* mobile);

  // optional .i18n.phonenumbers.PhoneNumberDesc toll_free = 4;
  inline bool has_toll_free() const;
  inline void clear_toll_free();
  static const int kTollFreeFieldNumber = 4;
  inline const ::i18n::phonenumbers::PhoneNumberDesc& toll_free() const;
  inline ::i18n::phonenumbers::PhoneNumberDesc* mutable_toll_free();
  inline ::i18n::phonenumbers::PhoneNumberDesc* release_toll_free();
  inline void set_allocated_toll_free(::i18n::phonenumbers::PhoneNumberDesc* toll_free);

  // optional .i18n.phonenumbers.PhoneNumberDesc premium_rate = 5;
  inline bool has_premium_rate() const;
  inline void clear_premium_rate();
  static const int kPremiumRateFieldNumber = 5;
  inline const ::i18n::phonenumbers::PhoneNumberDesc& premium_rate() const;
  inline ::i18n::phonenumbers::PhoneNumberDesc* mutable_premium_rate();
  inline ::i18n::phonenumbers::PhoneNumberDesc* release_premium_rate();
  inline void set_allocated_premium_rate(::i18n::phonenumbers::PhoneNumberDesc* premium_rate);

  // optional .i18n.phonenumbers.PhoneNumberDesc shared_cost = 6;
  inline bool has_shared_cost() const;
  inline void clear_shared_cost();
  static const int kSharedCostFieldNumber = 6;
  inline const ::i18n::phonenumbers::PhoneNumberDesc& shared_cost() const;
  inline ::i18n::phonenumbers::PhoneNumberDesc* mutable_shared_cost();
  inline ::i18n::phonenumbers::PhoneNumberDesc* release_shared_cost();
  inline void set_allocated_shared_cost(::i18n::phonenumbers::PhoneNumberDesc* shared_cost);

  // optional .i18n.phonenumbers.PhoneNumberDesc personal_number = 7;
  inline bool has_personal_number() const;
  inline void clear_personal_number();
  static const int kPersonalNumberFieldNumber = 7;
  inline const ::i18n::phonenumbers::PhoneNumberDesc& personal_number() const;
  inline ::i18n::phonenumbers::PhoneNumberDesc* mutable_personal_number();
  inline ::i18n::phonenumbers::PhoneNumberDesc* release_personal_number();
  inline void set_allocated_personal_number(::i18n::phonenumbers::PhoneNumberDesc* personal_number);

  // optional .i18n.phonenumbers.PhoneNumberDesc voip = 8;
  inline bool has_voip() const;
  inline void clear_voip();
  static const int kVoipFieldNumber = 8;
  inline const ::i18n::phonenumbers::PhoneNumberDesc& voip() const;
  inline ::i18n::phonenumbers::PhoneNumberDesc* mutable_voip();
  inline ::i18n::phonenumbers::PhoneNumberDesc* release_voip();
  inline void set_allocated_voip(::i18n::phonenumbers::PhoneNumberDesc* voip);

  // optional .i18n.phonenumbers.PhoneNumberDesc pager = 21;
  inline bool has_pager() const;
  inline void clear_pager();
  static const int kPagerFieldNumber = 21;
  inline const ::i18n::phonenumbers::PhoneNumberDesc& pager() const;
  inline ::i18n::phonenumbers::PhoneNumberDesc* mutable_pager();
  inline ::i18n::phonenumbers::PhoneNumberDesc* release_pager();
  inline void set_allocated_pager(::i18n::phonenumbers::PhoneNumberDesc* pager);

  // optional .i18n.phonenumbers.PhoneNumberDesc uan = 25;
  inline bool has_uan() const;
  inline void clear_uan();
  static const int kUanFieldNumber = 25;
  inline const ::i18n::phonenumbers::PhoneNumberDesc& uan() const;
  inline ::i18n::phonenumbers::PhoneNumberDesc* mutable_uan();
  inline ::i18n::phonenumbers::PhoneNumberDesc* release_uan();
  inline void set_allocated_uan(::i18n::phonenumbers::PhoneNumberDesc* uan);

  // optional .i18n.phonenumbers.PhoneNumberDesc emergency = 27;
  inline bool has_emergency() const;
  inline void clear_emergency();
  static const int kEmergencyFieldNumber = 27;
  inline const ::i18n::phonenumbers::PhoneNumberDesc& emergency() const;
  inline ::i18n::phonenumbers::PhoneNumberDesc* mutable_emergency();
  inline ::i18n::phonenumbers::PhoneNumberDesc* release_emergency();
  inline void set_allocated_emergency(::i18n::phonenumbers::PhoneNumberDesc* emergency);

  // optional .i18n.phonenumbers.PhoneNumberDesc voicemail = 28;
  inline bool has_voicemail() const;
  inline void clear_voicemail();
  static const int kVoicemailFieldNumber = 28;
  inline const ::i18n::phonenumbers::PhoneNumberDesc& voicemail() const;
  inline ::i18n::phonenumbers::PhoneNumberDesc* mutable_voicemail();
  inline ::i18n::phonenumbers::PhoneNumberDesc* release_voicemail();
  inline void set_allocated_voicemail(::i18n::phonenumbers::PhoneNumberDesc* voicemail);

  // optional .i18n.phonenumbers.PhoneNumberDesc short_code = 29;
  inline bool has_short_code() const;
  inline void clear_short_code();
  static const int kShortCodeFieldNumber = 29;
  inline const ::i18n::phonenumbers::PhoneNumberDesc& short_code() const;
  inline ::i18n::phonenumbers::PhoneNumberDesc* mutable_short_code();
  inline ::i18n::phonenumbers::PhoneNumberDesc* release_short_code();
  inline void set_allocated_short_code(::i18n::phonenumbers::PhoneNumberDesc* short_code);

  // optional .i18n.phonenumbers.PhoneNumberDesc standard_rate = 30;
  inline bool has_standard_rate() const;
  inline void clear_standard_rate();
  static const int kStandardRateFieldNumber = 30;
  inline const ::i18n::phonenumbers::PhoneNumberDesc& standard_rate() const;
  inline ::i18n::phonenumbers::PhoneNumberDesc* mutable_standard_rate();
  inline ::i18n::phonenumbers::PhoneNumberDesc* release_standard_rate();
  inline void set_allocated_standard_rate(::i18n::phonenumbers::PhoneNumberDesc* standard_rate);

  // optional .i18n.phonenumbers.PhoneNumberDesc carrier_specific = 31;
  inline bool has_carrier_specific() const;
  inline void clear_carrier_specific();
  static const int kCarrierSpecificFieldNumber = 31;
  inline const ::i18n::phonenumbers::PhoneNumberDesc& carrier_specific() const;
  inline ::i18n::phonenumbers::PhoneNumberDesc* mutable_carrier_specific();
  inline ::i18n::phonenumbers::PhoneNumberDesc* release_carrier_specific();
  inline void set_allocated_carrier_specific(::i18n::phonenumbers::PhoneNumberDesc* carrier_specific);

  // optional .i18n.phonenumbers.PhoneNumberDesc no_international_dialling = 24;
  inline bool has_no_international_dialling() const;
  inline void clear_no_international_dialling();
  static const int kNoInternationalDiallingFieldNumber = 24;
  inline const ::i18n::phonenumbers::PhoneNumberDesc& no_international_dialling() const;
  inline ::i18n::phonenumbers::PhoneNumberDesc* mutable_no_international_dialling();
  inline ::i18n::phonenumbers::PhoneNumberDesc* release_no_international_dialling();
  inline void set_allocated_no_international_dialling(::i18n::phonenumbers::PhoneNumberDesc* no_international_dialling);

  // required string id = 9;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 9;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional int32 country_code = 10;
  inline bool has_country_code() const;
  inline void clear_country_code();
  static const int kCountryCodeFieldNumber = 10;
  inline ::google::protobuf::int32 country_code() const;
  inline void set_country_code(::google::protobuf::int32 value);

  // optional string international_prefix = 11;
  inline bool has_international_prefix() const;
  inline void clear_international_prefix();
  static const int kInternationalPrefixFieldNumber = 11;
  inline const ::std::string& international_prefix() const;
  inline void set_international_prefix(const ::std::string& value);
  inline void set_international_prefix(const char* value);
  inline void set_international_prefix(const char* value, size_t size);
  inline ::std::string* mutable_international_prefix();
  inline ::std::string* release_international_prefix();
  inline void set_allocated_international_prefix(::std::string* international_prefix);

  // optional string preferred_international_prefix = 17;
  inline bool has_preferred_international_prefix() const;
  inline void clear_preferred_international_prefix();
  static const int kPreferredInternationalPrefixFieldNumber = 17;
  inline const ::std::string& preferred_international_prefix() const;
  inline void set_preferred_international_prefix(const ::std::string& value);
  inline void set_preferred_international_prefix(const char* value);
  inline void set_preferred_international_prefix(const char* value, size_t size);
  inline ::std::string* mutable_preferred_international_prefix();
  inline ::std::string* release_preferred_international_prefix();
  inline void set_allocated_preferred_international_prefix(::std::string* preferred_international_prefix);

  // optional string national_prefix = 12;
  inline bool has_national_prefix() const;
  inline void clear_national_prefix();
  static const int kNationalPrefixFieldNumber = 12;
  inline const ::std::string& national_prefix() const;
  inline void set_national_prefix(const ::std::string& value);
  inline void set_national_prefix(const char* value);
  inline void set_national_prefix(const char* value, size_t size);
  inline ::std::string* mutable_national_prefix();
  inline ::std::string* release_national_prefix();
  inline void set_allocated_national_prefix(::std::string* national_prefix);

  // optional string preferred_extn_prefix = 13;
  inline bool has_preferred_extn_prefix() const;
  inline void clear_preferred_extn_prefix();
  static const int kPreferredExtnPrefixFieldNumber = 13;
  inline const ::std::string& preferred_extn_prefix() const;
  inline void set_preferred_extn_prefix(const ::std::string& value);
  inline void set_preferred_extn_prefix(const char* value);
  inline void set_preferred_extn_prefix(const char* value, size_t size);
  inline ::std::string* mutable_preferred_extn_prefix();
  inline ::std::string* release_preferred_extn_prefix();
  inline void set_allocated_preferred_extn_prefix(::std::string* preferred_extn_prefix);

  // optional string national_prefix_for_parsing = 15;
  inline bool has_national_prefix_for_parsing() const;
  inline void clear_national_prefix_for_parsing();
  static const int kNationalPrefixForParsingFieldNumber = 15;
  inline const ::std::string& national_prefix_for_parsing() const;
  inline void set_national_prefix_for_parsing(const ::std::string& value);
  inline void set_national_prefix_for_parsing(const char* value);
  inline void set_national_prefix_for_parsing(const char* value, size_t size);
  inline ::std::string* mutable_national_prefix_for_parsing();
  inline ::std::string* release_national_prefix_for_parsing();
  inline void set_allocated_national_prefix_for_parsing(::std::string* national_prefix_for_parsing);

  // optional string national_prefix_transform_rule = 16;
  inline bool has_national_prefix_transform_rule() const;
  inline void clear_national_prefix_transform_rule();
  static const int kNationalPrefixTransformRuleFieldNumber = 16;
  inline const ::std::string& national_prefix_transform_rule() const;
  inline void set_national_prefix_transform_rule(const ::std::string& value);
  inline void set_national_prefix_transform_rule(const char* value);
  inline void set_national_prefix_transform_rule(const char* value, size_t size);
  inline ::std::string* mutable_national_prefix_transform_rule();
  inline ::std::string* release_national_prefix_transform_rule();
  inline void set_allocated_national_prefix_transform_rule(::std::string* national_prefix_transform_rule);

  // optional bool same_mobile_and_fixed_line_pattern = 18 [default = false];
  inline bool has_same_mobile_and_fixed_line_pattern() const;
  inline void clear_same_mobile_and_fixed_line_pattern();
  static const int kSameMobileAndFixedLinePatternFieldNumber = 18;
  inline bool same_mobile_and_fixed_line_pattern() const;
  inline void set_same_mobile_and_fixed_line_pattern(bool value);

  // repeated .i18n.phonenumbers.NumberFormat number_format = 19;
  inline int number_format_size() const;
  inline void clear_number_format();
  static const int kNumberFormatFieldNumber = 19;
  inline const ::i18n::phonenumbers::NumberFormat& number_format(int index) const;
  inline ::i18n::phonenumbers::NumberFormat* mutable_number_format(int index);
  inline ::i18n::phonenumbers::NumberFormat* add_number_format();
  inline const ::google::protobuf::RepeatedPtrField< ::i18n::phonenumbers::NumberFormat >&
      number_format() const;
  inline ::google::protobuf::RepeatedPtrField< ::i18n::phonenumbers::NumberFormat >*
      mutable_number_format();

  // repeated .i18n.phonenumbers.NumberFormat intl_number_format = 20;
  inline int intl_number_format_size() const;
  inline void clear_intl_number_format();
  static const int kIntlNumberFormatFieldNumber = 20;
  inline const ::i18n::phonenumbers::NumberFormat& intl_number_format(int index) const;
  inline ::i18n::phonenumbers::NumberFormat* mutable_intl_number_format(int index);
  inline ::i18n::phonenumbers::NumberFormat* add_intl_number_format();
  inline const ::google::protobuf::RepeatedPtrField< ::i18n::phonenumbers::NumberFormat >&
      intl_number_format() const;
  inline ::google::protobuf::RepeatedPtrField< ::i18n::phonenumbers::NumberFormat >*
      mutable_intl_number_format();

  // optional bool main_country_for_code = 22 [default = false];
  inline bool has_main_country_for_code() const;
  inline void clear_main_country_for_code();
  static const int kMainCountryForCodeFieldNumber = 22;
  inline bool main_country_for_code() const;
  inline void set_main_country_for_code(bool value);

  // optional string leading_digits = 23;
  inline bool has_leading_digits() const;
  inline void clear_leading_digits();
  static const int kLeadingDigitsFieldNumber = 23;
  inline const ::std::string& leading_digits() const;
  inline void set_leading_digits(const ::std::string& value);
  inline void set_leading_digits(const char* value);
  inline void set_leading_digits(const char* value, size_t size);
  inline ::std::string* mutable_leading_digits();
  inline ::std::string* release_leading_digits();
  inline void set_allocated_leading_digits(::std::string* leading_digits);

  // optional bool leading_zero_possible = 26 [default = false];
  inline bool has_leading_zero_possible() const;
  inline void clear_leading_zero_possible();
  static const int kLeadingZeroPossibleFieldNumber = 26;
  inline bool leading_zero_possible() const;
  inline void set_leading_zero_possible(bool value);

  // optional bool mobile_number_portable_region = 32 [default = false];
  inline bool has_mobile_number_portable_region() const;
  inline void clear_mobile_number_portable_region();
  static const int kMobileNumberPortableRegionFieldNumber = 32;
  inline bool mobile_number_portable_region() const;
  inline void set_mobile_number_portable_region(bool value);

  // @@protoc_insertion_point(class_scope:i18n.phonenumbers.PhoneMetadata)
 private:
  inline void set_has_general_desc();
  inline void clear_has_general_desc();
  inline void set_has_fixed_line();
  inline void clear_has_fixed_line();
  inline void set_has_mobile();
  inline void clear_has_mobile();
  inline void set_has_toll_free();
  inline void clear_has_toll_free();
  inline void set_has_premium_rate();
  inline void clear_has_premium_rate();
  inline void set_has_shared_cost();
  inline void clear_has_shared_cost();
  inline void set_has_personal_number();
  inline void clear_has_personal_number();
  inline void set_has_voip();
  inline void clear_has_voip();
  inline void set_has_pager();
  inline void clear_has_pager();
  inline void set_has_uan();
  inline void clear_has_uan();
  inline void set_has_emergency();
  inline void clear_has_emergency();
  inline void set_has_voicemail();
  inline void clear_has_voicemail();
  inline void set_has_short_code();
  inline void clear_has_short_code();
  inline void set_has_standard_rate();
  inline void clear_has_standard_rate();
  inline void set_has_carrier_specific();
  inline void clear_has_carrier_specific();
  inline void set_has_no_international_dialling();
  inline void clear_has_no_international_dialling();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_country_code();
  inline void clear_has_country_code();
  inline void set_has_international_prefix();
  inline void clear_has_international_prefix();
  inline void set_has_preferred_international_prefix();
  inline void clear_has_preferred_international_prefix();
  inline void set_has_national_prefix();
  inline void clear_has_national_prefix();
  inline void set_has_preferred_extn_prefix();
  inline void clear_has_preferred_extn_prefix();
  inline void set_has_national_prefix_for_parsing();
  inline void clear_has_national_prefix_for_parsing();
  inline void set_has_national_prefix_transform_rule();
  inline void clear_has_national_prefix_transform_rule();
  inline void set_has_same_mobile_and_fixed_line_pattern();
  inline void clear_has_same_mobile_and_fixed_line_pattern();
  inline void set_has_main_country_for_code();
  inline void clear_has_main_country_for_code();
  inline void set_has_leading_digits();
  inline void clear_has_leading_digits();
  inline void set_has_leading_zero_possible();
  inline void clear_has_leading_zero_possible();
  inline void set_has_mobile_number_portable_region();
  inline void clear_has_mobile_number_portable_region();

  ::i18n::phonenumbers::PhoneNumberDesc* general_desc_;
  ::i18n::phonenumbers::PhoneNumberDesc* fixed_line_;
  ::i18n::phonenumbers::PhoneNumberDesc* mobile_;
  ::i18n::phonenumbers::PhoneNumberDesc* toll_free_;
  ::i18n::phonenumbers::PhoneNumberDesc* premium_rate_;
  ::i18n::phonenumbers::PhoneNumberDesc* shared_cost_;
  ::i18n::phonenumbers::PhoneNumberDesc* personal_number_;
  ::i18n::phonenumbers::PhoneNumberDesc* voip_;
  ::i18n::phonenumbers::PhoneNumberDesc* pager_;
  ::i18n::phonenumbers::PhoneNumberDesc* uan_;
  ::i18n::phonenumbers::PhoneNumberDesc* emergency_;
  ::i18n::phonenumbers::PhoneNumberDesc* voicemail_;
  ::i18n::phonenumbers::PhoneNumberDesc* short_code_;
  ::i18n::phonenumbers::PhoneNumberDesc* standard_rate_;
  ::i18n::phonenumbers::PhoneNumberDesc* carrier_specific_;
  ::i18n::phonenumbers::PhoneNumberDesc* no_international_dialling_;
  ::std::string* id_;
  ::std::string* international_prefix_;
  ::std::string* preferred_international_prefix_;
  ::std::string* national_prefix_;
  ::std::string* preferred_extn_prefix_;
  ::std::string* national_prefix_for_parsing_;
  ::std::string* national_prefix_transform_rule_;
  ::google::protobuf::RepeatedPtrField< ::i18n::phonenumbers::NumberFormat > number_format_;
  ::google::protobuf::int32 country_code_;
  bool same_mobile_and_fixed_line_pattern_;
  bool main_country_for_code_;
  bool leading_zero_possible_;
  bool mobile_number_portable_region_;
  ::google::protobuf::RepeatedPtrField< ::i18n::phonenumbers::NumberFormat > intl_number_format_;
  ::std::string* leading_digits_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(31 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_phonemetadata_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_phonemetadata_2eproto();
  #endif
  friend void protobuf_AssignDesc_phonemetadata_2eproto();
  friend void protobuf_ShutdownFile_phonemetadata_2eproto();

  void InitAsDefaultInstance();
  static PhoneMetadata* default_instance_;
};
// -------------------------------------------------------------------

class PhoneMetadataCollection : public ::google::protobuf::MessageLite {
 public:
  PhoneMetadataCollection();
  virtual ~PhoneMetadataCollection();

  PhoneMetadataCollection(const PhoneMetadataCollection& from);

  inline PhoneMetadataCollection& operator=(const PhoneMetadataCollection& from) {
    CopyFrom(from);
    return *this;
  }

  static const PhoneMetadataCollection& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PhoneMetadataCollection* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PhoneMetadataCollection* other);

  // implements Message ----------------------------------------------

  PhoneMetadataCollection* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PhoneMetadataCollection& from);
  void MergeFrom(const PhoneMetadataCollection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .i18n.phonenumbers.PhoneMetadata metadata = 1;
  inline int metadata_size() const;
  inline void clear_metadata();
  static const int kMetadataFieldNumber = 1;
  inline const ::i18n::phonenumbers::PhoneMetadata& metadata(int index) const;
  inline ::i18n::phonenumbers::PhoneMetadata* mutable_metadata(int index);
  inline ::i18n::phonenumbers::PhoneMetadata* add_metadata();
  inline const ::google::protobuf::RepeatedPtrField< ::i18n::phonenumbers::PhoneMetadata >&
      metadata() const;
  inline ::google::protobuf::RepeatedPtrField< ::i18n::phonenumbers::PhoneMetadata >*
      mutable_metadata();

  // @@protoc_insertion_point(class_scope:i18n.phonenumbers.PhoneMetadataCollection)
 private:

  ::google::protobuf::RepeatedPtrField< ::i18n::phonenumbers::PhoneMetadata > metadata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_phonemetadata_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_phonemetadata_2eproto();
  #endif
  friend void protobuf_AssignDesc_phonemetadata_2eproto();
  friend void protobuf_ShutdownFile_phonemetadata_2eproto();

  void InitAsDefaultInstance();
  static PhoneMetadataCollection* default_instance_;
};
// ===================================================================


// ===================================================================

// NumberFormat

// required string pattern = 1;
inline bool NumberFormat::has_pattern() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NumberFormat::set_has_pattern() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NumberFormat::clear_has_pattern() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NumberFormat::clear_pattern() {
  if (pattern_ != &::google::protobuf::internal::kEmptyString) {
    pattern_->clear();
  }
  clear_has_pattern();
}
inline const ::std::string& NumberFormat::pattern() const {
  return *pattern_;
}
inline void NumberFormat::set_pattern(const ::std::string& value) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::kEmptyString) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(value);
}
inline void NumberFormat::set_pattern(const char* value) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::kEmptyString) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(value);
}
inline void NumberFormat::set_pattern(const char* value, size_t size) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::kEmptyString) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NumberFormat::mutable_pattern() {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::kEmptyString) {
    pattern_ = new ::std::string;
  }
  return pattern_;
}
inline ::std::string* NumberFormat::release_pattern() {
  clear_has_pattern();
  if (pattern_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pattern_;
    pattern_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NumberFormat::set_allocated_pattern(::std::string* pattern) {
  if (pattern_ != &::google::protobuf::internal::kEmptyString) {
    delete pattern_;
  }
  if (pattern) {
    set_has_pattern();
    pattern_ = pattern;
  } else {
    clear_has_pattern();
    pattern_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string format = 2;
inline bool NumberFormat::has_format() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NumberFormat::set_has_format() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NumberFormat::clear_has_format() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NumberFormat::clear_format() {
  if (format_ != &::google::protobuf::internal::kEmptyString) {
    format_->clear();
  }
  clear_has_format();
}
inline const ::std::string& NumberFormat::format() const {
  return *format_;
}
inline void NumberFormat::set_format(const ::std::string& value) {
  set_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    format_ = new ::std::string;
  }
  format_->assign(value);
}
inline void NumberFormat::set_format(const char* value) {
  set_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    format_ = new ::std::string;
  }
  format_->assign(value);
}
inline void NumberFormat::set_format(const char* value, size_t size) {
  set_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    format_ = new ::std::string;
  }
  format_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NumberFormat::mutable_format() {
  set_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    format_ = new ::std::string;
  }
  return format_;
}
inline ::std::string* NumberFormat::release_format() {
  clear_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = format_;
    format_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NumberFormat::set_allocated_format(::std::string* format) {
  if (format_ != &::google::protobuf::internal::kEmptyString) {
    delete format_;
  }
  if (format) {
    set_has_format();
    format_ = format;
  } else {
    clear_has_format();
    format_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string leading_digits_pattern = 3;
inline int NumberFormat::leading_digits_pattern_size() const {
  return leading_digits_pattern_.size();
}
inline void NumberFormat::clear_leading_digits_pattern() {
  leading_digits_pattern_.Clear();
}
inline const ::std::string& NumberFormat::leading_digits_pattern(int index) const {
  return leading_digits_pattern_.Get(index);
}
inline ::std::string* NumberFormat::mutable_leading_digits_pattern(int index) {
  return leading_digits_pattern_.Mutable(index);
}
inline void NumberFormat::set_leading_digits_pattern(int index, const ::std::string& value) {
  leading_digits_pattern_.Mutable(index)->assign(value);
}
inline void NumberFormat::set_leading_digits_pattern(int index, const char* value) {
  leading_digits_pattern_.Mutable(index)->assign(value);
}
inline void NumberFormat::set_leading_digits_pattern(int index, const char* value, size_t size) {
  leading_digits_pattern_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NumberFormat::add_leading_digits_pattern() {
  return leading_digits_pattern_.Add();
}
inline void NumberFormat::add_leading_digits_pattern(const ::std::string& value) {
  leading_digits_pattern_.Add()->assign(value);
}
inline void NumberFormat::add_leading_digits_pattern(const char* value) {
  leading_digits_pattern_.Add()->assign(value);
}
inline void NumberFormat::add_leading_digits_pattern(const char* value, size_t size) {
  leading_digits_pattern_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NumberFormat::leading_digits_pattern() const {
  return leading_digits_pattern_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NumberFormat::mutable_leading_digits_pattern() {
  return &leading_digits_pattern_;
}

// optional string national_prefix_formatting_rule = 4;
inline bool NumberFormat::has_national_prefix_formatting_rule() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NumberFormat::set_has_national_prefix_formatting_rule() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NumberFormat::clear_has_national_prefix_formatting_rule() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NumberFormat::clear_national_prefix_formatting_rule() {
  if (national_prefix_formatting_rule_ != &::google::protobuf::internal::kEmptyString) {
    national_prefix_formatting_rule_->clear();
  }
  clear_has_national_prefix_formatting_rule();
}
inline const ::std::string& NumberFormat::national_prefix_formatting_rule() const {
  return *national_prefix_formatting_rule_;
}
inline void NumberFormat::set_national_prefix_formatting_rule(const ::std::string& value) {
  set_has_national_prefix_formatting_rule();
  if (national_prefix_formatting_rule_ == &::google::protobuf::internal::kEmptyString) {
    national_prefix_formatting_rule_ = new ::std::string;
  }
  national_prefix_formatting_rule_->assign(value);
}
inline void NumberFormat::set_national_prefix_formatting_rule(const char* value) {
  set_has_national_prefix_formatting_rule();
  if (national_prefix_formatting_rule_ == &::google::protobuf::internal::kEmptyString) {
    national_prefix_formatting_rule_ = new ::std::string;
  }
  national_prefix_formatting_rule_->assign(value);
}
inline void NumberFormat::set_national_prefix_formatting_rule(const char* value, size_t size) {
  set_has_national_prefix_formatting_rule();
  if (national_prefix_formatting_rule_ == &::google::protobuf::internal::kEmptyString) {
    national_prefix_formatting_rule_ = new ::std::string;
  }
  national_prefix_formatting_rule_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NumberFormat::mutable_national_prefix_formatting_rule() {
  set_has_national_prefix_formatting_rule();
  if (national_prefix_formatting_rule_ == &::google::protobuf::internal::kEmptyString) {
    national_prefix_formatting_rule_ = new ::std::string;
  }
  return national_prefix_formatting_rule_;
}
inline ::std::string* NumberFormat::release_national_prefix_formatting_rule() {
  clear_has_national_prefix_formatting_rule();
  if (national_prefix_formatting_rule_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = national_prefix_formatting_rule_;
    national_prefix_formatting_rule_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NumberFormat::set_allocated_national_prefix_formatting_rule(::std::string* national_prefix_formatting_rule) {
  if (national_prefix_formatting_rule_ != &::google::protobuf::internal::kEmptyString) {
    delete national_prefix_formatting_rule_;
  }
  if (national_prefix_formatting_rule) {
    set_has_national_prefix_formatting_rule();
    national_prefix_formatting_rule_ = national_prefix_formatting_rule;
  } else {
    clear_has_national_prefix_formatting_rule();
    national_prefix_formatting_rule_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool national_prefix_optional_when_formatting = 6;
inline bool NumberFormat::has_national_prefix_optional_when_formatting() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NumberFormat::set_has_national_prefix_optional_when_formatting() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NumberFormat::clear_has_national_prefix_optional_when_formatting() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NumberFormat::clear_national_prefix_optional_when_formatting() {
  national_prefix_optional_when_formatting_ = false;
  clear_has_national_prefix_optional_when_formatting();
}
inline bool NumberFormat::national_prefix_optional_when_formatting() const {
  return national_prefix_optional_when_formatting_;
}
inline void NumberFormat::set_national_prefix_optional_when_formatting(bool value) {
  set_has_national_prefix_optional_when_formatting();
  national_prefix_optional_when_formatting_ = value;
}

// optional string domestic_carrier_code_formatting_rule = 5;
inline bool NumberFormat::has_domestic_carrier_code_formatting_rule() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NumberFormat::set_has_domestic_carrier_code_formatting_rule() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NumberFormat::clear_has_domestic_carrier_code_formatting_rule() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NumberFormat::clear_domestic_carrier_code_formatting_rule() {
  if (domestic_carrier_code_formatting_rule_ != &::google::protobuf::internal::kEmptyString) {
    domestic_carrier_code_formatting_rule_->clear();
  }
  clear_has_domestic_carrier_code_formatting_rule();
}
inline const ::std::string& NumberFormat::domestic_carrier_code_formatting_rule() const {
  return *domestic_carrier_code_formatting_rule_;
}
inline void NumberFormat::set_domestic_carrier_code_formatting_rule(const ::std::string& value) {
  set_has_domestic_carrier_code_formatting_rule();
  if (domestic_carrier_code_formatting_rule_ == &::google::protobuf::internal::kEmptyString) {
    domestic_carrier_code_formatting_rule_ = new ::std::string;
  }
  domestic_carrier_code_formatting_rule_->assign(value);
}
inline void NumberFormat::set_domestic_carrier_code_formatting_rule(const char* value) {
  set_has_domestic_carrier_code_formatting_rule();
  if (domestic_carrier_code_formatting_rule_ == &::google::protobuf::internal::kEmptyString) {
    domestic_carrier_code_formatting_rule_ = new ::std::string;
  }
  domestic_carrier_code_formatting_rule_->assign(value);
}
inline void NumberFormat::set_domestic_carrier_code_formatting_rule(const char* value, size_t size) {
  set_has_domestic_carrier_code_formatting_rule();
  if (domestic_carrier_code_formatting_rule_ == &::google::protobuf::internal::kEmptyString) {
    domestic_carrier_code_formatting_rule_ = new ::std::string;
  }
  domestic_carrier_code_formatting_rule_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NumberFormat::mutable_domestic_carrier_code_formatting_rule() {
  set_has_domestic_carrier_code_formatting_rule();
  if (domestic_carrier_code_formatting_rule_ == &::google::protobuf::internal::kEmptyString) {
    domestic_carrier_code_formatting_rule_ = new ::std::string;
  }
  return domestic_carrier_code_formatting_rule_;
}
inline ::std::string* NumberFormat::release_domestic_carrier_code_formatting_rule() {
  clear_has_domestic_carrier_code_formatting_rule();
  if (domestic_carrier_code_formatting_rule_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domestic_carrier_code_formatting_rule_;
    domestic_carrier_code_formatting_rule_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NumberFormat::set_allocated_domestic_carrier_code_formatting_rule(::std::string* domestic_carrier_code_formatting_rule) {
  if (domestic_carrier_code_formatting_rule_ != &::google::protobuf::internal::kEmptyString) {
    delete domestic_carrier_code_formatting_rule_;
  }
  if (domestic_carrier_code_formatting_rule) {
    set_has_domestic_carrier_code_formatting_rule();
    domestic_carrier_code_formatting_rule_ = domestic_carrier_code_formatting_rule;
  } else {
    clear_has_domestic_carrier_code_formatting_rule();
    domestic_carrier_code_formatting_rule_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PhoneNumberDesc

// optional string national_number_pattern = 2;
inline bool PhoneNumberDesc::has_national_number_pattern() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PhoneNumberDesc::set_has_national_number_pattern() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PhoneNumberDesc::clear_has_national_number_pattern() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PhoneNumberDesc::clear_national_number_pattern() {
  if (national_number_pattern_ != &::google::protobuf::internal::kEmptyString) {
    national_number_pattern_->clear();
  }
  clear_has_national_number_pattern();
}
inline const ::std::string& PhoneNumberDesc::national_number_pattern() const {
  return *national_number_pattern_;
}
inline void PhoneNumberDesc::set_national_number_pattern(const ::std::string& value) {
  set_has_national_number_pattern();
  if (national_number_pattern_ == &::google::protobuf::internal::kEmptyString) {
    national_number_pattern_ = new ::std::string;
  }
  national_number_pattern_->assign(value);
}
inline void PhoneNumberDesc::set_national_number_pattern(const char* value) {
  set_has_national_number_pattern();
  if (national_number_pattern_ == &::google::protobuf::internal::kEmptyString) {
    national_number_pattern_ = new ::std::string;
  }
  national_number_pattern_->assign(value);
}
inline void PhoneNumberDesc::set_national_number_pattern(const char* value, size_t size) {
  set_has_national_number_pattern();
  if (national_number_pattern_ == &::google::protobuf::internal::kEmptyString) {
    national_number_pattern_ = new ::std::string;
  }
  national_number_pattern_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhoneNumberDesc::mutable_national_number_pattern() {
  set_has_national_number_pattern();
  if (national_number_pattern_ == &::google::protobuf::internal::kEmptyString) {
    national_number_pattern_ = new ::std::string;
  }
  return national_number_pattern_;
}
inline ::std::string* PhoneNumberDesc::release_national_number_pattern() {
  clear_has_national_number_pattern();
  if (national_number_pattern_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = national_number_pattern_;
    national_number_pattern_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PhoneNumberDesc::set_allocated_national_number_pattern(::std::string* national_number_pattern) {
  if (national_number_pattern_ != &::google::protobuf::internal::kEmptyString) {
    delete national_number_pattern_;
  }
  if (national_number_pattern) {
    set_has_national_number_pattern();
    national_number_pattern_ = national_number_pattern;
  } else {
    clear_has_national_number_pattern();
    national_number_pattern_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string possible_number_pattern = 3;
inline bool PhoneNumberDesc::has_possible_number_pattern() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PhoneNumberDesc::set_has_possible_number_pattern() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PhoneNumberDesc::clear_has_possible_number_pattern() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PhoneNumberDesc::clear_possible_number_pattern() {
  if (possible_number_pattern_ != &::google::protobuf::internal::kEmptyString) {
    possible_number_pattern_->clear();
  }
  clear_has_possible_number_pattern();
}
inline const ::std::string& PhoneNumberDesc::possible_number_pattern() const {
  return *possible_number_pattern_;
}
inline void PhoneNumberDesc::set_possible_number_pattern(const ::std::string& value) {
  set_has_possible_number_pattern();
  if (possible_number_pattern_ == &::google::protobuf::internal::kEmptyString) {
    possible_number_pattern_ = new ::std::string;
  }
  possible_number_pattern_->assign(value);
}
inline void PhoneNumberDesc::set_possible_number_pattern(const char* value) {
  set_has_possible_number_pattern();
  if (possible_number_pattern_ == &::google::protobuf::internal::kEmptyString) {
    possible_number_pattern_ = new ::std::string;
  }
  possible_number_pattern_->assign(value);
}
inline void PhoneNumberDesc::set_possible_number_pattern(const char* value, size_t size) {
  set_has_possible_number_pattern();
  if (possible_number_pattern_ == &::google::protobuf::internal::kEmptyString) {
    possible_number_pattern_ = new ::std::string;
  }
  possible_number_pattern_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhoneNumberDesc::mutable_possible_number_pattern() {
  set_has_possible_number_pattern();
  if (possible_number_pattern_ == &::google::protobuf::internal::kEmptyString) {
    possible_number_pattern_ = new ::std::string;
  }
  return possible_number_pattern_;
}
inline ::std::string* PhoneNumberDesc::release_possible_number_pattern() {
  clear_has_possible_number_pattern();
  if (possible_number_pattern_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = possible_number_pattern_;
    possible_number_pattern_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PhoneNumberDesc::set_allocated_possible_number_pattern(::std::string* possible_number_pattern) {
  if (possible_number_pattern_ != &::google::protobuf::internal::kEmptyString) {
    delete possible_number_pattern_;
  }
  if (possible_number_pattern) {
    set_has_possible_number_pattern();
    possible_number_pattern_ = possible_number_pattern;
  } else {
    clear_has_possible_number_pattern();
    possible_number_pattern_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string example_number = 6;
inline bool PhoneNumberDesc::has_example_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PhoneNumberDesc::set_has_example_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PhoneNumberDesc::clear_has_example_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PhoneNumberDesc::clear_example_number() {
  if (example_number_ != &::google::protobuf::internal::kEmptyString) {
    example_number_->clear();
  }
  clear_has_example_number();
}
inline const ::std::string& PhoneNumberDesc::example_number() const {
  return *example_number_;
}
inline void PhoneNumberDesc::set_example_number(const ::std::string& value) {
  set_has_example_number();
  if (example_number_ == &::google::protobuf::internal::kEmptyString) {
    example_number_ = new ::std::string;
  }
  example_number_->assign(value);
}
inline void PhoneNumberDesc::set_example_number(const char* value) {
  set_has_example_number();
  if (example_number_ == &::google::protobuf::internal::kEmptyString) {
    example_number_ = new ::std::string;
  }
  example_number_->assign(value);
}
inline void PhoneNumberDesc::set_example_number(const char* value, size_t size) {
  set_has_example_number();
  if (example_number_ == &::google::protobuf::internal::kEmptyString) {
    example_number_ = new ::std::string;
  }
  example_number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhoneNumberDesc::mutable_example_number() {
  set_has_example_number();
  if (example_number_ == &::google::protobuf::internal::kEmptyString) {
    example_number_ = new ::std::string;
  }
  return example_number_;
}
inline ::std::string* PhoneNumberDesc::release_example_number() {
  clear_has_example_number();
  if (example_number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = example_number_;
    example_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PhoneNumberDesc::set_allocated_example_number(::std::string* example_number) {
  if (example_number_ != &::google::protobuf::internal::kEmptyString) {
    delete example_number_;
  }
  if (example_number) {
    set_has_example_number();
    example_number_ = example_number;
  } else {
    clear_has_example_number();
    example_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PhoneMetadata

// optional .i18n.phonenumbers.PhoneNumberDesc general_desc = 1;
inline bool PhoneMetadata::has_general_desc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PhoneMetadata::set_has_general_desc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PhoneMetadata::clear_has_general_desc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PhoneMetadata::clear_general_desc() {
  if (general_desc_ != NULL) general_desc_->::i18n::phonenumbers::PhoneNumberDesc::Clear();
  clear_has_general_desc();
}
inline const ::i18n::phonenumbers::PhoneNumberDesc& PhoneMetadata::general_desc() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return general_desc_ != NULL ? *general_desc_ : *default_instance().general_desc_;
#else
  return general_desc_ != NULL ? *general_desc_ : *default_instance_->general_desc_;
#endif
}
inline ::i18n::phonenumbers::PhoneNumberDesc* PhoneMetadata::mutable_general_desc() {
  set_has_general_desc();
  if (general_desc_ == NULL) general_desc_ = new ::i18n::phonenumbers::PhoneNumberDesc;
  return general_desc_;
}
inline ::i18n::phonenumbers::PhoneNumberDesc* PhoneMetadata::release_general_desc() {
  clear_has_general_desc();
  ::i18n::phonenumbers::PhoneNumberDesc* temp = general_desc_;
  general_desc_ = NULL;
  return temp;
}
inline void PhoneMetadata::set_allocated_general_desc(::i18n::phonenumbers::PhoneNumberDesc* general_desc) {
  delete general_desc_;
  general_desc_ = general_desc;
  if (general_desc) {
    set_has_general_desc();
  } else {
    clear_has_general_desc();
  }
}

// optional .i18n.phonenumbers.PhoneNumberDesc fixed_line = 2;
inline bool PhoneMetadata::has_fixed_line() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PhoneMetadata::set_has_fixed_line() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PhoneMetadata::clear_has_fixed_line() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PhoneMetadata::clear_fixed_line() {
  if (fixed_line_ != NULL) fixed_line_->::i18n::phonenumbers::PhoneNumberDesc::Clear();
  clear_has_fixed_line();
}
inline const ::i18n::phonenumbers::PhoneNumberDesc& PhoneMetadata::fixed_line() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fixed_line_ != NULL ? *fixed_line_ : *default_instance().fixed_line_;
#else
  return fixed_line_ != NULL ? *fixed_line_ : *default_instance_->fixed_line_;
#endif
}
inline ::i18n::phonenumbers::PhoneNumberDesc* PhoneMetadata::mutable_fixed_line() {
  set_has_fixed_line();
  if (fixed_line_ == NULL) fixed_line_ = new ::i18n::phonenumbers::PhoneNumberDesc;
  return fixed_line_;
}
inline ::i18n::phonenumbers::PhoneNumberDesc* PhoneMetadata::release_fixed_line() {
  clear_has_fixed_line();
  ::i18n::phonenumbers::PhoneNumberDesc* temp = fixed_line_;
  fixed_line_ = NULL;
  return temp;
}
inline void PhoneMetadata::set_allocated_fixed_line(::i18n::phonenumbers::PhoneNumberDesc* fixed_line) {
  delete fixed_line_;
  fixed_line_ = fixed_line;
  if (fixed_line) {
    set_has_fixed_line();
  } else {
    clear_has_fixed_line();
  }
}

// optional .i18n.phonenumbers.PhoneNumberDesc mobile = 3;
inline bool PhoneMetadata::has_mobile() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PhoneMetadata::set_has_mobile() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PhoneMetadata::clear_has_mobile() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PhoneMetadata::clear_mobile() {
  if (mobile_ != NULL) mobile_->::i18n::phonenumbers::PhoneNumberDesc::Clear();
  clear_has_mobile();
}
inline const ::i18n::phonenumbers::PhoneNumberDesc& PhoneMetadata::mobile() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return mobile_ != NULL ? *mobile_ : *default_instance().mobile_;
#else
  return mobile_ != NULL ? *mobile_ : *default_instance_->mobile_;
#endif
}
inline ::i18n::phonenumbers::PhoneNumberDesc* PhoneMetadata::mutable_mobile() {
  set_has_mobile();
  if (mobile_ == NULL) mobile_ = new ::i18n::phonenumbers::PhoneNumberDesc;
  return mobile_;
}
inline ::i18n::phonenumbers::PhoneNumberDesc* PhoneMetadata::release_mobile() {
  clear_has_mobile();
  ::i18n::phonenumbers::PhoneNumberDesc* temp = mobile_;
  mobile_ = NULL;
  return temp;
}
inline void PhoneMetadata::set_allocated_mobile(::i18n::phonenumbers::PhoneNumberDesc* mobile) {
  delete mobile_;
  mobile_ = mobile;
  if (mobile) {
    set_has_mobile();
  } else {
    clear_has_mobile();
  }
}

// optional .i18n.phonenumbers.PhoneNumberDesc toll_free = 4;
inline bool PhoneMetadata::has_toll_free() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PhoneMetadata::set_has_toll_free() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PhoneMetadata::clear_has_toll_free() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PhoneMetadata::clear_toll_free() {
  if (toll_free_ != NULL) toll_free_->::i18n::phonenumbers::PhoneNumberDesc::Clear();
  clear_has_toll_free();
}
inline const ::i18n::phonenumbers::PhoneNumberDesc& PhoneMetadata::toll_free() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return toll_free_ != NULL ? *toll_free_ : *default_instance().toll_free_;
#else
  return toll_free_ != NULL ? *toll_free_ : *default_instance_->toll_free_;
#endif
}
inline ::i18n::phonenumbers::PhoneNumberDesc* PhoneMetadata::mutable_toll_free() {
  set_has_toll_free();
  if (toll_free_ == NULL) toll_free_ = new ::i18n::phonenumbers::PhoneNumberDesc;
  return toll_free_;
}
inline ::i18n::phonenumbers::PhoneNumberDesc* PhoneMetadata::release_toll_free() {
  clear_has_toll_free();
  ::i18n::phonenumbers::PhoneNumberDesc* temp = toll_free_;
  toll_free_ = NULL;
  return temp;
}
inline void PhoneMetadata::set_allocated_toll_free(::i18n::phonenumbers::PhoneNumberDesc* toll_free) {
  delete toll_free_;
  toll_free_ = toll_free;
  if (toll_free) {
    set_has_toll_free();
  } else {
    clear_has_toll_free();
  }
}

// optional .i18n.phonenumbers.PhoneNumberDesc premium_rate = 5;
inline bool PhoneMetadata::has_premium_rate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PhoneMetadata::set_has_premium_rate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PhoneMetadata::clear_has_premium_rate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PhoneMetadata::clear_premium_rate() {
  if (premium_rate_ != NULL) premium_rate_->::i18n::phonenumbers::PhoneNumberDesc::Clear();
  clear_has_premium_rate();
}
inline const ::i18n::phonenumbers::PhoneNumberDesc& PhoneMetadata::premium_rate() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return premium_rate_ != NULL ? *premium_rate_ : *default_instance().premium_rate_;
#else
  return premium_rate_ != NULL ? *premium_rate_ : *default_instance_->premium_rate_;
#endif
}
inline ::i18n::phonenumbers::PhoneNumberDesc* PhoneMetadata::mutable_premium_rate() {
  set_has_premium_rate();
  if (premium_rate_ == NULL) premium_rate_ = new ::i18n::phonenumbers::PhoneNumberDesc;
  return premium_rate_;
}
inline ::i18n::phonenumbers::PhoneNumberDesc* PhoneMetadata::release_premium_rate() {
  clear_has_premium_rate();
  ::i18n::phonenumbers::PhoneNumberDesc* temp = premium_rate_;
  premium_rate_ = NULL;
  return temp;
}
inline void PhoneMetadata::set_allocated_premium_rate(::i18n::phonenumbers::PhoneNumberDesc* premium_rate) {
  delete premium_rate_;
  premium_rate_ = premium_rate;
  if (premium_rate) {
    set_has_premium_rate();
  } else {
    clear_has_premium_rate();
  }
}

// optional .i18n.phonenumbers.PhoneNumberDesc shared_cost = 6;
inline bool PhoneMetadata::has_shared_cost() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PhoneMetadata::set_has_shared_cost() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PhoneMetadata::clear_has_shared_cost() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PhoneMetadata::clear_shared_cost() {
  if (shared_cost_ != NULL) shared_cost_->::i18n::phonenumbers::PhoneNumberDesc::Clear();
  clear_has_shared_cost();
}
inline const ::i18n::phonenumbers::PhoneNumberDesc& PhoneMetadata::shared_cost() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return shared_cost_ != NULL ? *shared_cost_ : *default_instance().shared_cost_;
#else
  return shared_cost_ != NULL ? *shared_cost_ : *default_instance_->shared_cost_;
#endif
}
inline ::i18n::phonenumbers::PhoneNumberDesc* PhoneMetadata::mutable_shared_cost() {
  set_has_shared_cost();
  if (shared_cost_ == NULL) shared_cost_ = new ::i18n::phonenumbers::PhoneNumberDesc;
  return shared_cost_;
}
inline ::i18n::phonenumbers::PhoneNumberDesc* PhoneMetadata::release_shared_cost() {
  clear_has_shared_cost();
  ::i18n::phonenumbers::PhoneNumberDesc* temp = shared_cost_;
  shared_cost_ = NULL;
  return temp;
}
inline void PhoneMetadata::set_allocated_shared_cost(::i18n::phonenumbers::PhoneNumberDesc* shared_cost) {
  delete shared_cost_;
  shared_cost_ = shared_cost;
  if (shared_cost) {
    set_has_shared_cost();
  } else {
    clear_has_shared_cost();
  }
}

// optional .i18n.phonenumbers.PhoneNumberDesc personal_number = 7;
inline bool PhoneMetadata::has_personal_number() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PhoneMetadata::set_has_personal_number() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PhoneMetadata::clear_has_personal_number() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PhoneMetadata::clear_personal_number() {
  if (personal_number_ != NULL) personal_number_->::i18n::phonenumbers::PhoneNumberDesc::Clear();
  clear_has_personal_number();
}
inline const ::i18n::phonenumbers::PhoneNumberDesc& PhoneMetadata::personal_number() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return personal_number_ != NULL ? *personal_number_ : *default_instance().personal_number_;
#else
  return personal_number_ != NULL ? *personal_number_ : *default_instance_->personal_number_;
#endif
}
inline ::i18n::phonenumbers::PhoneNumberDesc* PhoneMetadata::mutable_personal_number() {
  set_has_personal_number();
  if (personal_number_ == NULL) personal_number_ = new ::i18n::phonenumbers::PhoneNumberDesc;
  return personal_number_;
}
inline ::i18n::phonenumbers::PhoneNumberDesc* PhoneMetadata::release_personal_number() {
  clear_has_personal_number();
  ::i18n::phonenumbers::PhoneNumberDesc* temp = personal_number_;
  personal_number_ = NULL;
  return temp;
}
inline void PhoneMetadata::set_allocated_personal_number(::i18n::phonenumbers::PhoneNumberDesc* personal_number) {
  delete personal_number_;
  personal_number_ = personal_number;
  if (personal_number) {
    set_has_personal_number();
  } else {
    clear_has_personal_number();
  }
}

// optional .i18n.phonenumbers.PhoneNumberDesc voip = 8;
inline bool PhoneMetadata::has_voip() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PhoneMetadata::set_has_voip() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PhoneMetadata::clear_has_voip() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PhoneMetadata::clear_voip() {
  if (voip_ != NULL) voip_->::i18n::phonenumbers::PhoneNumberDesc::Clear();
  clear_has_voip();
}
inline const ::i18n::phonenumbers::PhoneNumberDesc& PhoneMetadata::voip() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return voip_ != NULL ? *voip_ : *default_instance().voip_;
#else
  return voip_ != NULL ? *voip_ : *default_instance_->voip_;
#endif
}
inline ::i18n::phonenumbers::PhoneNumberDesc* PhoneMetadata::mutable_voip() {
  set_has_voip();
  if (voip_ == NULL) voip_ = new ::i18n::phonenumbers::PhoneNumberDesc;
  return voip_;
}
inline ::i18n::phonenumbers::PhoneNumberDesc* PhoneMetadata::release_voip() {
  clear_has_voip();
  ::i18n::phonenumbers::PhoneNumberDesc* temp = voip_;
  voip_ = NULL;
  return temp;
}
inline void PhoneMetadata::set_allocated_voip(::i18n::phonenumbers::PhoneNumberDesc* voip) {
  delete voip_;
  voip_ = voip;
  if (voip) {
    set_has_voip();
  } else {
    clear_has_voip();
  }
}

// optional .i18n.phonenumbers.PhoneNumberDesc pager = 21;
inline bool PhoneMetadata::has_pager() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PhoneMetadata::set_has_pager() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PhoneMetadata::clear_has_pager() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PhoneMetadata::clear_pager() {
  if (pager_ != NULL) pager_->::i18n::phonenumbers::PhoneNumberDesc::Clear();
  clear_has_pager();
}
inline const ::i18n::phonenumbers::PhoneNumberDesc& PhoneMetadata::pager() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return pager_ != NULL ? *pager_ : *default_instance().pager_;
#else
  return pager_ != NULL ? *pager_ : *default_instance_->pager_;
#endif
}
inline ::i18n::phonenumbers::PhoneNumberDesc* PhoneMetadata::mutable_pager() {
  set_has_pager();
  if (pager_ == NULL) pager_ = new ::i18n::phonenumbers::PhoneNumberDesc;
  return pager_;
}
inline ::i18n::phonenumbers::PhoneNumberDesc* PhoneMetadata::release_pager() {
  clear_has_pager();
  ::i18n::phonenumbers::PhoneNumberDesc* temp = pager_;
  pager_ = NULL;
  return temp;
}
inline void PhoneMetadata::set_allocated_pager(::i18n::phonenumbers::PhoneNumberDesc* pager) {
  delete pager_;
  pager_ = pager;
  if (pager) {
    set_has_pager();
  } else {
    clear_has_pager();
  }
}

// optional .i18n.phonenumbers.PhoneNumberDesc uan = 25;
inline bool PhoneMetadata::has_uan() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PhoneMetadata::set_has_uan() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PhoneMetadata::clear_has_uan() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PhoneMetadata::clear_uan() {
  if (uan_ != NULL) uan_->::i18n::phonenumbers::PhoneNumberDesc::Clear();
  clear_has_uan();
}
inline const ::i18n::phonenumbers::PhoneNumberDesc& PhoneMetadata::uan() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return uan_ != NULL ? *uan_ : *default_instance().uan_;
#else
  return uan_ != NULL ? *uan_ : *default_instance_->uan_;
#endif
}
inline ::i18n::phonenumbers::PhoneNumberDesc* PhoneMetadata::mutable_uan() {
  set_has_uan();
  if (uan_ == NULL) uan_ = new ::i18n::phonenumbers::PhoneNumberDesc;
  return uan_;
}
inline ::i18n::phonenumbers::PhoneNumberDesc* PhoneMetadata::release_uan() {
  clear_has_uan();
  ::i18n::phonenumbers::PhoneNumberDesc* temp = uan_;
  uan_ = NULL;
  return temp;
}
inline void PhoneMetadata::set_allocated_uan(::i18n::phonenumbers::PhoneNumberDesc* uan) {
  delete uan_;
  uan_ = uan;
  if (uan) {
    set_has_uan();
  } else {
    clear_has_uan();
  }
}

// optional .i18n.phonenumbers.PhoneNumberDesc emergency = 27;
inline bool PhoneMetadata::has_emergency() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PhoneMetadata::set_has_emergency() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PhoneMetadata::clear_has_emergency() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PhoneMetadata::clear_emergency() {
  if (emergency_ != NULL) emergency_->::i18n::phonenumbers::PhoneNumberDesc::Clear();
  clear_has_emergency();
}
inline const ::i18n::phonenumbers::PhoneNumberDesc& PhoneMetadata::emergency() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return emergency_ != NULL ? *emergency_ : *default_instance().emergency_;
#else
  return emergency_ != NULL ? *emergency_ : *default_instance_->emergency_;
#endif
}
inline ::i18n::phonenumbers::PhoneNumberDesc* PhoneMetadata::mutable_emergency() {
  set_has_emergency();
  if (emergency_ == NULL) emergency_ = new ::i18n::phonenumbers::PhoneNumberDesc;
  return emergency_;
}
inline ::i18n::phonenumbers::PhoneNumberDesc* PhoneMetadata::release_emergency() {
  clear_has_emergency();
  ::i18n::phonenumbers::PhoneNumberDesc* temp = emergency_;
  emergency_ = NULL;
  return temp;
}
inline void PhoneMetadata::set_allocated_emergency(::i18n::phonenumbers::PhoneNumberDesc* emergency) {
  delete emergency_;
  emergency_ = emergency;
  if (emergency) {
    set_has_emergency();
  } else {
    clear_has_emergency();
  }
}

// optional .i18n.phonenumbers.PhoneNumberDesc voicemail = 28;
inline bool PhoneMetadata::has_voicemail() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PhoneMetadata::set_has_voicemail() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PhoneMetadata::clear_has_voicemail() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PhoneMetadata::clear_voicemail() {
  if (voicemail_ != NULL) voicemail_->::i18n::phonenumbers::PhoneNumberDesc::Clear();
  clear_has_voicemail();
}
inline const ::i18n::phonenumbers::PhoneNumberDesc& PhoneMetadata::voicemail() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return voicemail_ != NULL ? *voicemail_ : *default_instance().voicemail_;
#else
  return voicemail_ != NULL ? *voicemail_ : *default_instance_->voicemail_;
#endif
}
inline ::i18n::phonenumbers::PhoneNumberDesc* PhoneMetadata::mutable_voicemail() {
  set_has_voicemail();
  if (voicemail_ == NULL) voicemail_ = new ::i18n::phonenumbers::PhoneNumberDesc;
  return voicemail_;
}
inline ::i18n::phonenumbers::PhoneNumberDesc* PhoneMetadata::release_voicemail() {
  clear_has_voicemail();
  ::i18n::phonenumbers::PhoneNumberDesc* temp = voicemail_;
  voicemail_ = NULL;
  return temp;
}
inline void PhoneMetadata::set_allocated_voicemail(::i18n::phonenumbers::PhoneNumberDesc* voicemail) {
  delete voicemail_;
  voicemail_ = voicemail;
  if (voicemail) {
    set_has_voicemail();
  } else {
    clear_has_voicemail();
  }
}

// optional .i18n.phonenumbers.PhoneNumberDesc short_code = 29;
inline bool PhoneMetadata::has_short_code() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PhoneMetadata::set_has_short_code() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PhoneMetadata::clear_has_short_code() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PhoneMetadata::clear_short_code() {
  if (short_code_ != NULL) short_code_->::i18n::phonenumbers::PhoneNumberDesc::Clear();
  clear_has_short_code();
}
inline const ::i18n::phonenumbers::PhoneNumberDesc& PhoneMetadata::short_code() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return short_code_ != NULL ? *short_code_ : *default_instance().short_code_;
#else
  return short_code_ != NULL ? *short_code_ : *default_instance_->short_code_;
#endif
}
inline ::i18n::phonenumbers::PhoneNumberDesc* PhoneMetadata::mutable_short_code() {
  set_has_short_code();
  if (short_code_ == NULL) short_code_ = new ::i18n::phonenumbers::PhoneNumberDesc;
  return short_code_;
}
inline ::i18n::phonenumbers::PhoneNumberDesc* PhoneMetadata::release_short_code() {
  clear_has_short_code();
  ::i18n::phonenumbers::PhoneNumberDesc* temp = short_code_;
  short_code_ = NULL;
  return temp;
}
inline void PhoneMetadata::set_allocated_short_code(::i18n::phonenumbers::PhoneNumberDesc* short_code) {
  delete short_code_;
  short_code_ = short_code;
  if (short_code) {
    set_has_short_code();
  } else {
    clear_has_short_code();
  }
}

// optional .i18n.phonenumbers.PhoneNumberDesc standard_rate = 30;
inline bool PhoneMetadata::has_standard_rate() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PhoneMetadata::set_has_standard_rate() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PhoneMetadata::clear_has_standard_rate() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PhoneMetadata::clear_standard_rate() {
  if (standard_rate_ != NULL) standard_rate_->::i18n::phonenumbers::PhoneNumberDesc::Clear();
  clear_has_standard_rate();
}
inline const ::i18n::phonenumbers::PhoneNumberDesc& PhoneMetadata::standard_rate() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return standard_rate_ != NULL ? *standard_rate_ : *default_instance().standard_rate_;
#else
  return standard_rate_ != NULL ? *standard_rate_ : *default_instance_->standard_rate_;
#endif
}
inline ::i18n::phonenumbers::PhoneNumberDesc* PhoneMetadata::mutable_standard_rate() {
  set_has_standard_rate();
  if (standard_rate_ == NULL) standard_rate_ = new ::i18n::phonenumbers::PhoneNumberDesc;
  return standard_rate_;
}
inline ::i18n::phonenumbers::PhoneNumberDesc* PhoneMetadata::release_standard_rate() {
  clear_has_standard_rate();
  ::i18n::phonenumbers::PhoneNumberDesc* temp = standard_rate_;
  standard_rate_ = NULL;
  return temp;
}
inline void PhoneMetadata::set_allocated_standard_rate(::i18n::phonenumbers::PhoneNumberDesc* standard_rate) {
  delete standard_rate_;
  standard_rate_ = standard_rate;
  if (standard_rate) {
    set_has_standard_rate();
  } else {
    clear_has_standard_rate();
  }
}

// optional .i18n.phonenumbers.PhoneNumberDesc carrier_specific = 31;
inline bool PhoneMetadata::has_carrier_specific() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PhoneMetadata::set_has_carrier_specific() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PhoneMetadata::clear_has_carrier_specific() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PhoneMetadata::clear_carrier_specific() {
  if (carrier_specific_ != NULL) carrier_specific_->::i18n::phonenumbers::PhoneNumberDesc::Clear();
  clear_has_carrier_specific();
}
inline const ::i18n::phonenumbers::PhoneNumberDesc& PhoneMetadata::carrier_specific() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return carrier_specific_ != NULL ? *carrier_specific_ : *default_instance().carrier_specific_;
#else
  return carrier_specific_ != NULL ? *carrier_specific_ : *default_instance_->carrier_specific_;
#endif
}
inline ::i18n::phonenumbers::PhoneNumberDesc* PhoneMetadata::mutable_carrier_specific() {
  set_has_carrier_specific();
  if (carrier_specific_ == NULL) carrier_specific_ = new ::i18n::phonenumbers::PhoneNumberDesc;
  return carrier_specific_;
}
inline ::i18n::phonenumbers::PhoneNumberDesc* PhoneMetadata::release_carrier_specific() {
  clear_has_carrier_specific();
  ::i18n::phonenumbers::PhoneNumberDesc* temp = carrier_specific_;
  carrier_specific_ = NULL;
  return temp;
}
inline void PhoneMetadata::set_allocated_carrier_specific(::i18n::phonenumbers::PhoneNumberDesc* carrier_specific) {
  delete carrier_specific_;
  carrier_specific_ = carrier_specific;
  if (carrier_specific) {
    set_has_carrier_specific();
  } else {
    clear_has_carrier_specific();
  }
}

// optional .i18n.phonenumbers.PhoneNumberDesc no_international_dialling = 24;
inline bool PhoneMetadata::has_no_international_dialling() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PhoneMetadata::set_has_no_international_dialling() {
  _has_bits_[0] |= 0x00008000u;
}
inline void PhoneMetadata::clear_has_no_international_dialling() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void PhoneMetadata::clear_no_international_dialling() {
  if (no_international_dialling_ != NULL) no_international_dialling_->::i18n::phonenumbers::PhoneNumberDesc::Clear();
  clear_has_no_international_dialling();
}
inline const ::i18n::phonenumbers::PhoneNumberDesc& PhoneMetadata::no_international_dialling() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return no_international_dialling_ != NULL ? *no_international_dialling_ : *default_instance().no_international_dialling_;
#else
  return no_international_dialling_ != NULL ? *no_international_dialling_ : *default_instance_->no_international_dialling_;
#endif
}
inline ::i18n::phonenumbers::PhoneNumberDesc* PhoneMetadata::mutable_no_international_dialling() {
  set_has_no_international_dialling();
  if (no_international_dialling_ == NULL) no_international_dialling_ = new ::i18n::phonenumbers::PhoneNumberDesc;
  return no_international_dialling_;
}
inline ::i18n::phonenumbers::PhoneNumberDesc* PhoneMetadata::release_no_international_dialling() {
  clear_has_no_international_dialling();
  ::i18n::phonenumbers::PhoneNumberDesc* temp = no_international_dialling_;
  no_international_dialling_ = NULL;
  return temp;
}
inline void PhoneMetadata::set_allocated_no_international_dialling(::i18n::phonenumbers::PhoneNumberDesc* no_international_dialling) {
  delete no_international_dialling_;
  no_international_dialling_ = no_international_dialling;
  if (no_international_dialling) {
    set_has_no_international_dialling();
  } else {
    clear_has_no_international_dialling();
  }
}

// required string id = 9;
inline bool PhoneMetadata::has_id() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void PhoneMetadata::set_has_id() {
  _has_bits_[0] |= 0x00010000u;
}
inline void PhoneMetadata::clear_has_id() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void PhoneMetadata::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& PhoneMetadata::id() const {
  return *id_;
}
inline void PhoneMetadata::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void PhoneMetadata::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void PhoneMetadata::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhoneMetadata::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* PhoneMetadata::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PhoneMetadata::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 country_code = 10;
inline bool PhoneMetadata::has_country_code() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void PhoneMetadata::set_has_country_code() {
  _has_bits_[0] |= 0x00020000u;
}
inline void PhoneMetadata::clear_has_country_code() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void PhoneMetadata::clear_country_code() {
  country_code_ = 0;
  clear_has_country_code();
}
inline ::google::protobuf::int32 PhoneMetadata::country_code() const {
  return country_code_;
}
inline void PhoneMetadata::set_country_code(::google::protobuf::int32 value) {
  set_has_country_code();
  country_code_ = value;
}

// optional string international_prefix = 11;
inline bool PhoneMetadata::has_international_prefix() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void PhoneMetadata::set_has_international_prefix() {
  _has_bits_[0] |= 0x00040000u;
}
inline void PhoneMetadata::clear_has_international_prefix() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void PhoneMetadata::clear_international_prefix() {
  if (international_prefix_ != &::google::protobuf::internal::kEmptyString) {
    international_prefix_->clear();
  }
  clear_has_international_prefix();
}
inline const ::std::string& PhoneMetadata::international_prefix() const {
  return *international_prefix_;
}
inline void PhoneMetadata::set_international_prefix(const ::std::string& value) {
  set_has_international_prefix();
  if (international_prefix_ == &::google::protobuf::internal::kEmptyString) {
    international_prefix_ = new ::std::string;
  }
  international_prefix_->assign(value);
}
inline void PhoneMetadata::set_international_prefix(const char* value) {
  set_has_international_prefix();
  if (international_prefix_ == &::google::protobuf::internal::kEmptyString) {
    international_prefix_ = new ::std::string;
  }
  international_prefix_->assign(value);
}
inline void PhoneMetadata::set_international_prefix(const char* value, size_t size) {
  set_has_international_prefix();
  if (international_prefix_ == &::google::protobuf::internal::kEmptyString) {
    international_prefix_ = new ::std::string;
  }
  international_prefix_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhoneMetadata::mutable_international_prefix() {
  set_has_international_prefix();
  if (international_prefix_ == &::google::protobuf::internal::kEmptyString) {
    international_prefix_ = new ::std::string;
  }
  return international_prefix_;
}
inline ::std::string* PhoneMetadata::release_international_prefix() {
  clear_has_international_prefix();
  if (international_prefix_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = international_prefix_;
    international_prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PhoneMetadata::set_allocated_international_prefix(::std::string* international_prefix) {
  if (international_prefix_ != &::google::protobuf::internal::kEmptyString) {
    delete international_prefix_;
  }
  if (international_prefix) {
    set_has_international_prefix();
    international_prefix_ = international_prefix;
  } else {
    clear_has_international_prefix();
    international_prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string preferred_international_prefix = 17;
inline bool PhoneMetadata::has_preferred_international_prefix() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void PhoneMetadata::set_has_preferred_international_prefix() {
  _has_bits_[0] |= 0x00080000u;
}
inline void PhoneMetadata::clear_has_preferred_international_prefix() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void PhoneMetadata::clear_preferred_international_prefix() {
  if (preferred_international_prefix_ != &::google::protobuf::internal::kEmptyString) {
    preferred_international_prefix_->clear();
  }
  clear_has_preferred_international_prefix();
}
inline const ::std::string& PhoneMetadata::preferred_international_prefix() const {
  return *preferred_international_prefix_;
}
inline void PhoneMetadata::set_preferred_international_prefix(const ::std::string& value) {
  set_has_preferred_international_prefix();
  if (preferred_international_prefix_ == &::google::protobuf::internal::kEmptyString) {
    preferred_international_prefix_ = new ::std::string;
  }
  preferred_international_prefix_->assign(value);
}
inline void PhoneMetadata::set_preferred_international_prefix(const char* value) {
  set_has_preferred_international_prefix();
  if (preferred_international_prefix_ == &::google::protobuf::internal::kEmptyString) {
    preferred_international_prefix_ = new ::std::string;
  }
  preferred_international_prefix_->assign(value);
}
inline void PhoneMetadata::set_preferred_international_prefix(const char* value, size_t size) {
  set_has_preferred_international_prefix();
  if (preferred_international_prefix_ == &::google::protobuf::internal::kEmptyString) {
    preferred_international_prefix_ = new ::std::string;
  }
  preferred_international_prefix_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhoneMetadata::mutable_preferred_international_prefix() {
  set_has_preferred_international_prefix();
  if (preferred_international_prefix_ == &::google::protobuf::internal::kEmptyString) {
    preferred_international_prefix_ = new ::std::string;
  }
  return preferred_international_prefix_;
}
inline ::std::string* PhoneMetadata::release_preferred_international_prefix() {
  clear_has_preferred_international_prefix();
  if (preferred_international_prefix_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = preferred_international_prefix_;
    preferred_international_prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PhoneMetadata::set_allocated_preferred_international_prefix(::std::string* preferred_international_prefix) {
  if (preferred_international_prefix_ != &::google::protobuf::internal::kEmptyString) {
    delete preferred_international_prefix_;
  }
  if (preferred_international_prefix) {
    set_has_preferred_international_prefix();
    preferred_international_prefix_ = preferred_international_prefix;
  } else {
    clear_has_preferred_international_prefix();
    preferred_international_prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string national_prefix = 12;
inline bool PhoneMetadata::has_national_prefix() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void PhoneMetadata::set_has_national_prefix() {
  _has_bits_[0] |= 0x00100000u;
}
inline void PhoneMetadata::clear_has_national_prefix() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void PhoneMetadata::clear_national_prefix() {
  if (national_prefix_ != &::google::protobuf::internal::kEmptyString) {
    national_prefix_->clear();
  }
  clear_has_national_prefix();
}
inline const ::std::string& PhoneMetadata::national_prefix() const {
  return *national_prefix_;
}
inline void PhoneMetadata::set_national_prefix(const ::std::string& value) {
  set_has_national_prefix();
  if (national_prefix_ == &::google::protobuf::internal::kEmptyString) {
    national_prefix_ = new ::std::string;
  }
  national_prefix_->assign(value);
}
inline void PhoneMetadata::set_national_prefix(const char* value) {
  set_has_national_prefix();
  if (national_prefix_ == &::google::protobuf::internal::kEmptyString) {
    national_prefix_ = new ::std::string;
  }
  national_prefix_->assign(value);
}
inline void PhoneMetadata::set_national_prefix(const char* value, size_t size) {
  set_has_national_prefix();
  if (national_prefix_ == &::google::protobuf::internal::kEmptyString) {
    national_prefix_ = new ::std::string;
  }
  national_prefix_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhoneMetadata::mutable_national_prefix() {
  set_has_national_prefix();
  if (national_prefix_ == &::google::protobuf::internal::kEmptyString) {
    national_prefix_ = new ::std::string;
  }
  return national_prefix_;
}
inline ::std::string* PhoneMetadata::release_national_prefix() {
  clear_has_national_prefix();
  if (national_prefix_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = national_prefix_;
    national_prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PhoneMetadata::set_allocated_national_prefix(::std::string* national_prefix) {
  if (national_prefix_ != &::google::protobuf::internal::kEmptyString) {
    delete national_prefix_;
  }
  if (national_prefix) {
    set_has_national_prefix();
    national_prefix_ = national_prefix;
  } else {
    clear_has_national_prefix();
    national_prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string preferred_extn_prefix = 13;
inline bool PhoneMetadata::has_preferred_extn_prefix() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void PhoneMetadata::set_has_preferred_extn_prefix() {
  _has_bits_[0] |= 0x00200000u;
}
inline void PhoneMetadata::clear_has_preferred_extn_prefix() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void PhoneMetadata::clear_preferred_extn_prefix() {
  if (preferred_extn_prefix_ != &::google::protobuf::internal::kEmptyString) {
    preferred_extn_prefix_->clear();
  }
  clear_has_preferred_extn_prefix();
}
inline const ::std::string& PhoneMetadata::preferred_extn_prefix() const {
  return *preferred_extn_prefix_;
}
inline void PhoneMetadata::set_preferred_extn_prefix(const ::std::string& value) {
  set_has_preferred_extn_prefix();
  if (preferred_extn_prefix_ == &::google::protobuf::internal::kEmptyString) {
    preferred_extn_prefix_ = new ::std::string;
  }
  preferred_extn_prefix_->assign(value);
}
inline void PhoneMetadata::set_preferred_extn_prefix(const char* value) {
  set_has_preferred_extn_prefix();
  if (preferred_extn_prefix_ == &::google::protobuf::internal::kEmptyString) {
    preferred_extn_prefix_ = new ::std::string;
  }
  preferred_extn_prefix_->assign(value);
}
inline void PhoneMetadata::set_preferred_extn_prefix(const char* value, size_t size) {
  set_has_preferred_extn_prefix();
  if (preferred_extn_prefix_ == &::google::protobuf::internal::kEmptyString) {
    preferred_extn_prefix_ = new ::std::string;
  }
  preferred_extn_prefix_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhoneMetadata::mutable_preferred_extn_prefix() {
  set_has_preferred_extn_prefix();
  if (preferred_extn_prefix_ == &::google::protobuf::internal::kEmptyString) {
    preferred_extn_prefix_ = new ::std::string;
  }
  return preferred_extn_prefix_;
}
inline ::std::string* PhoneMetadata::release_preferred_extn_prefix() {
  clear_has_preferred_extn_prefix();
  if (preferred_extn_prefix_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = preferred_extn_prefix_;
    preferred_extn_prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PhoneMetadata::set_allocated_preferred_extn_prefix(::std::string* preferred_extn_prefix) {
  if (preferred_extn_prefix_ != &::google::protobuf::internal::kEmptyString) {
    delete preferred_extn_prefix_;
  }
  if (preferred_extn_prefix) {
    set_has_preferred_extn_prefix();
    preferred_extn_prefix_ = preferred_extn_prefix;
  } else {
    clear_has_preferred_extn_prefix();
    preferred_extn_prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string national_prefix_for_parsing = 15;
inline bool PhoneMetadata::has_national_prefix_for_parsing() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void PhoneMetadata::set_has_national_prefix_for_parsing() {
  _has_bits_[0] |= 0x00400000u;
}
inline void PhoneMetadata::clear_has_national_prefix_for_parsing() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void PhoneMetadata::clear_national_prefix_for_parsing() {
  if (national_prefix_for_parsing_ != &::google::protobuf::internal::kEmptyString) {
    national_prefix_for_parsing_->clear();
  }
  clear_has_national_prefix_for_parsing();
}
inline const ::std::string& PhoneMetadata::national_prefix_for_parsing() const {
  return *national_prefix_for_parsing_;
}
inline void PhoneMetadata::set_national_prefix_for_parsing(const ::std::string& value) {
  set_has_national_prefix_for_parsing();
  if (national_prefix_for_parsing_ == &::google::protobuf::internal::kEmptyString) {
    national_prefix_for_parsing_ = new ::std::string;
  }
  national_prefix_for_parsing_->assign(value);
}
inline void PhoneMetadata::set_national_prefix_for_parsing(const char* value) {
  set_has_national_prefix_for_parsing();
  if (national_prefix_for_parsing_ == &::google::protobuf::internal::kEmptyString) {
    national_prefix_for_parsing_ = new ::std::string;
  }
  national_prefix_for_parsing_->assign(value);
}
inline void PhoneMetadata::set_national_prefix_for_parsing(const char* value, size_t size) {
  set_has_national_prefix_for_parsing();
  if (national_prefix_for_parsing_ == &::google::protobuf::internal::kEmptyString) {
    national_prefix_for_parsing_ = new ::std::string;
  }
  national_prefix_for_parsing_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhoneMetadata::mutable_national_prefix_for_parsing() {
  set_has_national_prefix_for_parsing();
  if (national_prefix_for_parsing_ == &::google::protobuf::internal::kEmptyString) {
    national_prefix_for_parsing_ = new ::std::string;
  }
  return national_prefix_for_parsing_;
}
inline ::std::string* PhoneMetadata::release_national_prefix_for_parsing() {
  clear_has_national_prefix_for_parsing();
  if (national_prefix_for_parsing_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = national_prefix_for_parsing_;
    national_prefix_for_parsing_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PhoneMetadata::set_allocated_national_prefix_for_parsing(::std::string* national_prefix_for_parsing) {
  if (national_prefix_for_parsing_ != &::google::protobuf::internal::kEmptyString) {
    delete national_prefix_for_parsing_;
  }
  if (national_prefix_for_parsing) {
    set_has_national_prefix_for_parsing();
    national_prefix_for_parsing_ = national_prefix_for_parsing;
  } else {
    clear_has_national_prefix_for_parsing();
    national_prefix_for_parsing_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string national_prefix_transform_rule = 16;
inline bool PhoneMetadata::has_national_prefix_transform_rule() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void PhoneMetadata::set_has_national_prefix_transform_rule() {
  _has_bits_[0] |= 0x00800000u;
}
inline void PhoneMetadata::clear_has_national_prefix_transform_rule() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void PhoneMetadata::clear_national_prefix_transform_rule() {
  if (national_prefix_transform_rule_ != &::google::protobuf::internal::kEmptyString) {
    national_prefix_transform_rule_->clear();
  }
  clear_has_national_prefix_transform_rule();
}
inline const ::std::string& PhoneMetadata::national_prefix_transform_rule() const {
  return *national_prefix_transform_rule_;
}
inline void PhoneMetadata::set_national_prefix_transform_rule(const ::std::string& value) {
  set_has_national_prefix_transform_rule();
  if (national_prefix_transform_rule_ == &::google::protobuf::internal::kEmptyString) {
    national_prefix_transform_rule_ = new ::std::string;
  }
  national_prefix_transform_rule_->assign(value);
}
inline void PhoneMetadata::set_national_prefix_transform_rule(const char* value) {
  set_has_national_prefix_transform_rule();
  if (national_prefix_transform_rule_ == &::google::protobuf::internal::kEmptyString) {
    national_prefix_transform_rule_ = new ::std::string;
  }
  national_prefix_transform_rule_->assign(value);
}
inline void PhoneMetadata::set_national_prefix_transform_rule(const char* value, size_t size) {
  set_has_national_prefix_transform_rule();
  if (national_prefix_transform_rule_ == &::google::protobuf::internal::kEmptyString) {
    national_prefix_transform_rule_ = new ::std::string;
  }
  national_prefix_transform_rule_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhoneMetadata::mutable_national_prefix_transform_rule() {
  set_has_national_prefix_transform_rule();
  if (national_prefix_transform_rule_ == &::google::protobuf::internal::kEmptyString) {
    national_prefix_transform_rule_ = new ::std::string;
  }
  return national_prefix_transform_rule_;
}
inline ::std::string* PhoneMetadata::release_national_prefix_transform_rule() {
  clear_has_national_prefix_transform_rule();
  if (national_prefix_transform_rule_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = national_prefix_transform_rule_;
    national_prefix_transform_rule_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PhoneMetadata::set_allocated_national_prefix_transform_rule(::std::string* national_prefix_transform_rule) {
  if (national_prefix_transform_rule_ != &::google::protobuf::internal::kEmptyString) {
    delete national_prefix_transform_rule_;
  }
  if (national_prefix_transform_rule) {
    set_has_national_prefix_transform_rule();
    national_prefix_transform_rule_ = national_prefix_transform_rule;
  } else {
    clear_has_national_prefix_transform_rule();
    national_prefix_transform_rule_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool same_mobile_and_fixed_line_pattern = 18 [default = false];
inline bool PhoneMetadata::has_same_mobile_and_fixed_line_pattern() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void PhoneMetadata::set_has_same_mobile_and_fixed_line_pattern() {
  _has_bits_[0] |= 0x01000000u;
}
inline void PhoneMetadata::clear_has_same_mobile_and_fixed_line_pattern() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void PhoneMetadata::clear_same_mobile_and_fixed_line_pattern() {
  same_mobile_and_fixed_line_pattern_ = false;
  clear_has_same_mobile_and_fixed_line_pattern();
}
inline bool PhoneMetadata::same_mobile_and_fixed_line_pattern() const {
  return same_mobile_and_fixed_line_pattern_;
}
inline void PhoneMetadata::set_same_mobile_and_fixed_line_pattern(bool value) {
  set_has_same_mobile_and_fixed_line_pattern();
  same_mobile_and_fixed_line_pattern_ = value;
}

// repeated .i18n.phonenumbers.NumberFormat number_format = 19;
inline int PhoneMetadata::number_format_size() const {
  return number_format_.size();
}
inline void PhoneMetadata::clear_number_format() {
  number_format_.Clear();
}
inline const ::i18n::phonenumbers::NumberFormat& PhoneMetadata::number_format(int index) const {
  return number_format_.Get(index);
}
inline ::i18n::phonenumbers::NumberFormat* PhoneMetadata::mutable_number_format(int index) {
  return number_format_.Mutable(index);
}
inline ::i18n::phonenumbers::NumberFormat* PhoneMetadata::add_number_format() {
  return number_format_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::i18n::phonenumbers::NumberFormat >&
PhoneMetadata::number_format() const {
  return number_format_;
}
inline ::google::protobuf::RepeatedPtrField< ::i18n::phonenumbers::NumberFormat >*
PhoneMetadata::mutable_number_format() {
  return &number_format_;
}

// repeated .i18n.phonenumbers.NumberFormat intl_number_format = 20;
inline int PhoneMetadata::intl_number_format_size() const {
  return intl_number_format_.size();
}
inline void PhoneMetadata::clear_intl_number_format() {
  intl_number_format_.Clear();
}
inline const ::i18n::phonenumbers::NumberFormat& PhoneMetadata::intl_number_format(int index) const {
  return intl_number_format_.Get(index);
}
inline ::i18n::phonenumbers::NumberFormat* PhoneMetadata::mutable_intl_number_format(int index) {
  return intl_number_format_.Mutable(index);
}
inline ::i18n::phonenumbers::NumberFormat* PhoneMetadata::add_intl_number_format() {
  return intl_number_format_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::i18n::phonenumbers::NumberFormat >&
PhoneMetadata::intl_number_format() const {
  return intl_number_format_;
}
inline ::google::protobuf::RepeatedPtrField< ::i18n::phonenumbers::NumberFormat >*
PhoneMetadata::mutable_intl_number_format() {
  return &intl_number_format_;
}

// optional bool main_country_for_code = 22 [default = false];
inline bool PhoneMetadata::has_main_country_for_code() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void PhoneMetadata::set_has_main_country_for_code() {
  _has_bits_[0] |= 0x08000000u;
}
inline void PhoneMetadata::clear_has_main_country_for_code() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void PhoneMetadata::clear_main_country_for_code() {
  main_country_for_code_ = false;
  clear_has_main_country_for_code();
}
inline bool PhoneMetadata::main_country_for_code() const {
  return main_country_for_code_;
}
inline void PhoneMetadata::set_main_country_for_code(bool value) {
  set_has_main_country_for_code();
  main_country_for_code_ = value;
}

// optional string leading_digits = 23;
inline bool PhoneMetadata::has_leading_digits() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void PhoneMetadata::set_has_leading_digits() {
  _has_bits_[0] |= 0x10000000u;
}
inline void PhoneMetadata::clear_has_leading_digits() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void PhoneMetadata::clear_leading_digits() {
  if (leading_digits_ != &::google::protobuf::internal::kEmptyString) {
    leading_digits_->clear();
  }
  clear_has_leading_digits();
}
inline const ::std::string& PhoneMetadata::leading_digits() const {
  return *leading_digits_;
}
inline void PhoneMetadata::set_leading_digits(const ::std::string& value) {
  set_has_leading_digits();
  if (leading_digits_ == &::google::protobuf::internal::kEmptyString) {
    leading_digits_ = new ::std::string;
  }
  leading_digits_->assign(value);
}
inline void PhoneMetadata::set_leading_digits(const char* value) {
  set_has_leading_digits();
  if (leading_digits_ == &::google::protobuf::internal::kEmptyString) {
    leading_digits_ = new ::std::string;
  }
  leading_digits_->assign(value);
}
inline void PhoneMetadata::set_leading_digits(const char* value, size_t size) {
  set_has_leading_digits();
  if (leading_digits_ == &::google::protobuf::internal::kEmptyString) {
    leading_digits_ = new ::std::string;
  }
  leading_digits_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhoneMetadata::mutable_leading_digits() {
  set_has_leading_digits();
  if (leading_digits_ == &::google::protobuf::internal::kEmptyString) {
    leading_digits_ = new ::std::string;
  }
  return leading_digits_;
}
inline ::std::string* PhoneMetadata::release_leading_digits() {
  clear_has_leading_digits();
  if (leading_digits_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leading_digits_;
    leading_digits_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PhoneMetadata::set_allocated_leading_digits(::std::string* leading_digits) {
  if (leading_digits_ != &::google::protobuf::internal::kEmptyString) {
    delete leading_digits_;
  }
  if (leading_digits) {
    set_has_leading_digits();
    leading_digits_ = leading_digits;
  } else {
    clear_has_leading_digits();
    leading_digits_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool leading_zero_possible = 26 [default = false];
inline bool PhoneMetadata::has_leading_zero_possible() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void PhoneMetadata::set_has_leading_zero_possible() {
  _has_bits_[0] |= 0x20000000u;
}
inline void PhoneMetadata::clear_has_leading_zero_possible() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void PhoneMetadata::clear_leading_zero_possible() {
  leading_zero_possible_ = false;
  clear_has_leading_zero_possible();
}
inline bool PhoneMetadata::leading_zero_possible() const {
  return leading_zero_possible_;
}
inline void PhoneMetadata::set_leading_zero_possible(bool value) {
  set_has_leading_zero_possible();
  leading_zero_possible_ = value;
}

// optional bool mobile_number_portable_region = 32 [default = false];
inline bool PhoneMetadata::has_mobile_number_portable_region() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void PhoneMetadata::set_has_mobile_number_portable_region() {
  _has_bits_[0] |= 0x40000000u;
}
inline void PhoneMetadata::clear_has_mobile_number_portable_region() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void PhoneMetadata::clear_mobile_number_portable_region() {
  mobile_number_portable_region_ = false;
  clear_has_mobile_number_portable_region();
}
inline bool PhoneMetadata::mobile_number_portable_region() const {
  return mobile_number_portable_region_;
}
inline void PhoneMetadata::set_mobile_number_portable_region(bool value) {
  set_has_mobile_number_portable_region();
  mobile_number_portable_region_ = value;
}

// -------------------------------------------------------------------

// PhoneMetadataCollection

// repeated .i18n.phonenumbers.PhoneMetadata metadata = 1;
inline int PhoneMetadataCollection::metadata_size() const {
  return metadata_.size();
}
inline void PhoneMetadataCollection::clear_metadata() {
  metadata_.Clear();
}
inline const ::i18n::phonenumbers::PhoneMetadata& PhoneMetadataCollection::metadata(int index) const {
  return metadata_.Get(index);
}
inline ::i18n::phonenumbers::PhoneMetadata* PhoneMetadataCollection::mutable_metadata(int index) {
  return metadata_.Mutable(index);
}
inline ::i18n::phonenumbers::PhoneMetadata* PhoneMetadataCollection::add_metadata() {
  return metadata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::i18n::phonenumbers::PhoneMetadata >&
PhoneMetadataCollection::metadata() const {
  return metadata_;
}
inline ::google::protobuf::RepeatedPtrField< ::i18n::phonenumbers::PhoneMetadata >*
PhoneMetadataCollection::mutable_metadata() {
  return &metadata_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace phonenumbers
}  // namespace i18n

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_phonemetadata_2eproto__INCLUDED
